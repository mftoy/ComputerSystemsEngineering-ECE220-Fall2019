; I start my code with getting the char from keyboard and echoed the
; char to the screen. After that, char evaluated at the subroutine evaluate
; did necessary process. Subroutine has an output register R2. If program
; encounters an error or equal sign inputted, output set to 1 otherwise it is
; kept at 0. Then, our loop continues getting input char until R2 set to 0.
; How evaluate subroutine work will be explained.
;
;	R0 INPUT CHAR
;	R1 CHAR CHECK
;	R2 SUBROUTINE OUTPUT
;	R3 INPUT TO SUBROUTINES
;	R4 INPUT TO SUBROUTINES
;	R5 OUTPUT OF PUSH/POP
;	R6 NOT USED

.ORIG x3000
;your code goes here

GET_CHAR
	GETC		;CHAR READ FROM KEYBOARD
	OUT		;CHAR ECHOED TO SCREEN
	JSR EVALUATE	;ALGORITHM JUMPS TO SUBROUTINE
	ADD R2, R2, #0	;MAKE R2 RECENT REGISTER
	BRnz GET_CHAR	;GET NEW CHAR IF R2 IS ZERO
	HALT


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;R3- value to print in hexadecimal
; THIS SUBROUTINE PRINTS HEXADECIMAL NUMBER. IT IS
; ADJUSTED FROM MP1
PRINT_HEX
	ST R7, PRINT_SAVER7 ; SAVE R7 AS OUT TRAP IS USED
	AND R1,R1,#0	; CLEARS THE REGISTER
	LD R1,ASC_AT	; SET REGISTER AS ASCII @
	AND R4,R4,#0	; CLEAR THE REGISTER
	ADD R4,R4,#4	; STORE NUMBER 4 TO COUNT PRINTED HEXADECIMAL CHAR
	ADD R5,R3,#0	; R3 COPIED TO R5 TO ADJUST REST OF THE CODE

GET_HEX
	AND R0,R0,#0	; CLEAR THE CHAR OUTPUT REGISTER
	ADD R5,R5,#0	; MAKE SURE R5 IS THE RECENT REGISTER
	BRzp ADD_DECFOUR	; IF BIT IS ZERO, SLIDE LEFT
	ADD R0,R0,#8	; IF BIT IS ONE, ADD 8 TO THE OUTPUT


ADD_DECFOUR
	ADD R5,R5,R5	; SLIDE BITS TO THE LEFT
	BRzp ADD_DECTWO	; IF BIT IS ZERO, SLIDE LEFT
	ADD R0,R0,#4	; IF BIT IS ONE, ADD 4 TO THE OUTPUT


ADD_DECTWO
	ADD R5,R5,R5	; SLIDE BITS TO THE LEFT
	BRzp ADD_DECONE	; IF BIT IS ZERO, SLIDE LEFT
	ADD R0,R0,#2	; IF BIT IS ONE, ADD 2 TO THE OUTPUT


ADD_DECONE
	ADD R5,R5,R5	; SLIDE BITS TO THE LEFT
	BRzp PRINTING	; IF BIT IS ZERO, START PRINTING AND SLIDE LEFT
	ADD R0,R0,#1	; IF BIT IS ONE, ADD 1 TO THE OUTPUT


PRINTING
	ADD R5,R5,R5	; SLIDE BITS TO THE LEFT
	AND R6,R6,#0	; CLEAR THE REGISTER
	ADD R6,R0,#-9	; CHECK IF OUTPUT IS BIGGER THAN 9
	BRp PRINT_ATLEASTA	; IF OUTPUT IS BIGGER THAN 1, MOVE ON TO PRINT CHAR
	LD R6,ASC_ZERO	; LOAD ASCII VALUE OF ZERO
	ADD R0,R0,R6	; TURN OUTPUT TO ASCII VALUE OF THAT NUMBER
	OUT	; PRINT HEXADECIMAL CHARATER
	BRnzp LOOP_CHECK	; MOVE ON TO SEE IF I PRINTED 4 CHARS FOR HISTOGRAM VALUE

PRINT_ATLEASTA
	ADD R0,R6,R1	; ASSIGN ASCII VALUR FOR NUMBER BIGGER THAN 9
	OUT	; PRINT THE CHAR

LOOP_CHECK
	ADD R4,R4,#-1	; DECREMENT R4 i.e. ONE MORE CHAR PRINTED FOR HISTOGRAM VALUE
	BRp GET_HEX	; IF NOT 4 CHARS PRINTED, KEEP GOING
	LD R7, PRINT_SAVER7 ; LOAD R7 FROM MEMORY
	RET

PRINT_SAVER7 .BLKW	#1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;R0 - character input from keyboard
;R2 - current numerical output
EVALUATE
;SUBROUTINE STARTS WITH SAVING R7 AS I WILL BE USING SUBROUTINE INSIDE THE ALGORITHM
;LATER, I WILL ASSIGN NEGATIVE ASCII VALUE OF OPERATORS AND IF OUTPUT IS ZERO, I WILL
;POP TWO NUMBERS AND PUT THEM THROUGH RELATED SUBROUTINE. IF INPUT IS SPACE, IT WILL
;NOT DO ANYTHING. IF EQUAL INPUTTED, IT WILL POP 2 VALUES FROM STACK. IF R1 IS NOT 1
;AT THE SECOND POP, IT WILL PRINT ERROR CODE. IF INPUT IS NUMBER/OPERAND, SUBROUTINE
;WILL PUSH IT TO STACK. IF THIS SUBROUTINE GETS ANOTHER CHAR, IT WILL PRINT ERROR CODE


	ST R7, EVALUATE_SAVER7	; SAVE R7 AS I WILL USE SUBROUTINES

	LD R1, NEG_PLUS	; LOAD NEGATIVE '+' FROM MEMORY
	ADD R1, R0, R1 ; ADD NEGATIVE '+' TO INPUT CHAR
	BRz EVALUATE_PLUS ; IF ZERO, CONDUCT ADDITION

	LD R1, NEG_MINUS ;LOAD NEGATIVE '-' FROM MEMORY
	ADD R1, R0, R1 ;ADD NEGATIVE '-' TO INPUT CHAR
	BRz EVALUATE_MINUS ;IF ZERO, CONDUCT SUBTRACTION

	LD R1, NEG_MUL ;LOAD NEGATIVE '*' FROM MEMORY
	ADD R1, R0, R1 ;ADD NEGATIVE '*' TO INPUT CHAR
	BRz EVALUATE_MUL ;IF ZERO, CONDUCT MULTIPLICATION

	LD R1, NEG_DIV ;LOAD NEGATIVE '/' FROM MEMORY
	ADD R1, R0, R1 ;ADD NEGATIVE '/' TO INPUT CHAR
	BRz EVALUATE_DIV ;IF ZERO, CONDUCT DIVISION

	LD R1, NEG_EXP ;LOAD NEGATIVE '^' FROM MEMORY
	ADD R1, R0, R1 ;ADD NEGATIVE '^' TO INPUT CHAR
	BRz EVALUATE_EXP ;IF ZERO, CONDUCT DIVISION

	LD R1, NEG_SPACE ;LOAD NEGATIVE ' ' FROM MEMORY
	ADD R1,R0,R1 ;ADD NEGATIVE ' ' TO INPUT CHAR
	BRz REG_EXIT ;IF ZERO, WAIT FOR NEW CHAR

	LD R1, NEG_EQUAL ;LOAD NEGATIVE '=' FROM MEMORY
	ADD R1,R0,R1	;ADD NEGATIVE '=' TO INPUT CHAR
	BRz PROC_EQUAL ;IF ZERO, WAIT FOR NEW CHAR

	LD R1, NEG_ZERO ;LOAD NEGATIVE '0' FROM MEMORY
	ADD R0, R0, R1 ;ADD NEGATIVE '0' TO INPUT CHAR
	BRn ERROR 	;IF NEGATIVE, INVALID CHAR
	ADD R2, R0, #-9 ; DEDUCT -9 FROM INPUT
	BRp ERROR	; IF POSITIVE, INVALID CHAR
	JSR PUSH	; OTHERWISE, PUSH THE NUMBER TO THE STACK
	LD R7, EVALUATE_SAVER7	; LOAD R7 BACK
	RET		; RETURN BACK FROM SUBROUTINE

EVALUATE_PLUS
	JSR POP ; POP FIRST NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R3, R0, #0	; COPY R0 TO R3

	JSR POP	; POP THE SECOND NUMBER FROM STACK
	ADD R5,R5, #0	; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R4, R0, #0 ; COPY R0 TO R4

	JSR PLUS ; CALL PLUS SUBROUTINE TO CONDUCT ADDITION
	JSR PUSH ; PUSH THE RESULT OF ADDITION TO STACK
	LD R7, EVALUATE_SAVER7	;LOAD R7
	RET ; EXIT SUBROUTINE

EVALUATE_MINUS
	JSR POP ; POP FIRST NUMBER FROM STACK
	ADD R5,R5, #0; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R3, R0, #0; COPY R0 TO R3

	JSR POP ; POP THE SECOND NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R4, R0, #0 ; COPY R0 TO R4

	JSR MIN ; CALL PLUS SUBROUTINE TO CONDUCT SUBTRACTION
	JSR PUSH ; PUSH THE RESULT OF SUBTRACTION TO STACK
	LD R7, EVALUATE_SAVER7	;LOAD R7
	RET  ; EXIT SUBROUTINE

EVALUATE_MUL
	JSR POP ; POP FIRST NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R3, R0, #0 ; COPY R0 TO R3

	JSR POP ; POP THE SECOND NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R4, R0, #0 ; COPY R0 TO R4

	JSR MUL ; CALL PLUS SUBROUTINE TO CONDUCT MULTIPLICATION
	JSR PUSH ; PUSH THE RESULT OF MULTIPLICATION TO STACK
	LD R7, EVALUATE_SAVER7
	RET	; EXIT SUBROUTINE

EVALUATE_DIV
	JSR POP ; POP FIRST NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R3, R0, #0 ; COPY R0 TO R3

	JSR POP ; POP THE SECOND NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR ; IF OUTPUT 1, UNDEFLOW
	ADD R4, R0, #0	; COPY R0 TO R4

	JSR DIV ; CALL PLUS SUBROUTINE TO CONDUCT DIVISION
	JSR PUSH ; PUSH THE RESULT OF DIVISION TO STACK
	LD R7, EVALUATE_SAVER7	 ;LOAD R7
	RET ; EXIT SUBROUTINE

EVALUATE_EXP
	JSR POP ; POP FIRST NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR  ; IF OUTPUT 1, UNDEFLOW
	ADD R3, R0, #0 ; COPY R0 TO R3

	JSR POP ; POP THE SECOND NUMBER FROM STACK
	ADD R5,R5, #0 ; MAKE R5 RECENT
	BRp ERROR  ; IF OUTPUT 1, UNDEFLOW
	ADD R4, R0, #0	; COPY R0 TO R4

	JSR EXP ; CALL PLUS SUBROUTINE TO CONDUCT POWER
	JSR PUSH ; PUSH THE RESULT OF POWER TO STACK
	LD R7, EVALUATE_SAVER7	 ;LOAD R7
	RET; EXIT SUBROUTINE

REG_EXIT
	LD R7, EVALUATE_SAVER7	; ;LOAD R7
	RET; EXIT SUBROUTINE

PROC_EQUAL
	AND R2, R2,#0	; INITIATE R2
	ADD R2, R2, #1 ; ADD 1 TO R2 TO INDICATE = ENTERED
	JSR POP	; POP THE NUMBER FROM STACK
	JSR POP ; POP ANOTHER NUMBER FROM STACK
	ADD R5, R5, #0 ; IF OUTPUT 1, ONLY ONE CHAR IN THE STOCK
	BRnz ERROR ; IF NOT ONE CHAR, PRINT ERROR CODE
	ADD R3, R0, #0 ; COPY NUMBER TO R3
	JSR PRINT_HEX ; PRINT THE NUMBER ON SCREEN
	LD R7, EVALUATE_SAVER7	; LOAD R7
	RET ; EXIT SUBROUTINE

ERROR
	LEA R0, ERROR_EXP ; LOAD START OF STRING FROM MEMORY
	PUTS ; PRINT 'Invalid Expression' ON SCREEN
	AND R2, R2, #0 ; INITIATE R2
	ADD R2, R2, #1 ; ADD 1 TO R2 TO STOP THE PROGRAM
	LD R7, EVALUATE_SAVER7	; LOAD R7
	RET ; EXIT SUBROUTINE

EVALUATE_SAVER7 .BLKW #1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
PLUS
;SIMPLE ADDITION USING REGULAR OPERATIONS

	ADD R0, R3,R4 ; ADD R3, R3 AND STORE IN R0
	RET ; EXIT SUBROUTINE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
MIN
;R3 IS THE 1ST CHAR FROM STACK. ACCORDING TO FILO, EQUATION IS
; R4 -R3. THEREFORE, I MAKE R3 NEGATIVE AND ADD TO R4.

	NOT R3, R3 ; BITWISE NOT ON R3
	ADD R3, R3, #1	; ADD 1 TO MAKE IT -R3
	ADD R0, R4,R3 ; ADD R4 TO R3 AND STORE THE RESULT IN R0
	RET	; EXIT SUBROUTINE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
MUL
;I WILL CREATE A LOOP TO MULTIPLE R4 BY ITSELF FOR R3 TIMES.
	AND R0, R0, #0	; INITIATE R0
MUL_LOOP
	ADD R0, R0, R4	; ADD R4 ONE MORE TIME
	ADD R3, R3, #-1 ; DECREMENT R3
	BRp MUL_LOOP ; IF POSITIVE CONTINUE ADDITION
	RET	; EXIT SUBROUTINE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
DIV
;MY ALGORITHM TO CALCULATE DIVISION IS SUBTRACT R3 FROM R4 UNTIL
;OUTPUT IS ZERO OR NEGATIVE. THUS, I WILL MAKE R3 NEGATIVE AND THEN
; ADD IT R4 AS LONG AS R4 POSITIVE
	NOT R3, R3 ; BITWISE NOT R3
	ADD R3, R3, #1 ;MAKE R3 NEGATIVE
	AND R0, R0, #0 ; INITIATE OUTPUT
DIV_LOOP
	ADD R4, R4, R3 ; SUBSTRACT R3 FROM R4 ONE MORE TIME
	BRn DONE_DIV ; IF NEGATIVE, DIVISION DONE
	ADD R0, R0, #1 ; ADD 1 TO THE OUTPUT
	BRnzp DIV_LOOP ; CONTINUE SUBTRACTION

DONE_DIV
	RET ; EXIT SUBROUTINE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
EXP
;TO CALCULATE POWER, I WILL MULTIPLE R4 BY ITSELF R3 TIMES. OUTPUT WILL BE STORED IN R0
	ST R2, EXP_SAVER2 ; SAVE R2
	ST R7, EXP_SAVER7 ; SAVE R7
	ADD R2,R3, #-1 ; DECREMENT R3 IN COUNT LOOP
	ADD R3, R4, #0 ; COPY R4 TO R3
EXP_LOOP
	JSR MUL ; MULTIPLE R4 BY ITSELF
	ADD R2, R2, #-1 ; DECREMENT R2
	BRnz EXP_DONE ; ; IF R2 ZERO, OPERATION DONE
	ADD R3, R0, #0 ;COPY OUTPUT TO R3 B/C IT IS INPUT TO MULTIPLICATION
	BRnzp EXP_LOOP ; KEEP MULTIPLYING R4 R3 TIMES
EXP_DONE
	LD R2, EXP_SAVER2 ; LOAD R2
	LD R7, EXP_SAVER7 ; LOAD R7
	RET ; EXIT SUBROUTINE

EXP_SAVER2 .BLKW #1
EXP_SAVER7 .BLKW #1

;IN:R0, OUT:R5 (0-success, 1-fail/overflow)
;R3: STACK_END R4: STACK_TOP
;
PUSH
        ST R3, PUSH_SaveR3      ;save R3
        ST R4, PUSH_SaveR4      ;save R4
        AND R5, R5, #0          ;
        LD R3, STACK_END        ;
        LD R4, STACk_TOP        ;
        ADD R3, R3, #-1         ;
        NOT R3, R3              ;
        ADD R3, R3, #1          ;
        ADD R3, R3, R4          ;
        BRz OVERFLOW            ;stack is full
        STR R0, R4, #0          ;no overflow, store value in the stack
        ADD R4, R4, #-1         ;move top of the stack
        ST R4, STACK_TOP        ;store top of stack pointer
        BRnzp DONE_PUSH         ;
OVERFLOW
        ADD R5, R5, #1          ;
DONE_PUSH
        LD R3, PUSH_SaveR3      ;
        LD R4, PUSH_SaveR4      ;
        RET


PUSH_SaveR3     .BLKW #1        ;
PUSH_SaveR4     .BLKW #1        ;


;OUT: R0, OUT R5 (0-success, 1-fail/underflow)
;R3 STACK_START R4 STACK_TOP
;
POP
	ST R3, POP_SaveR3	;save R3
	ST R4, POP_SaveR4	;save R3
	AND R5, R5, #0		;clear R5
	LD R3, STACK_START	;
	LD R4, STACK_TOP	;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz UNDERFLOW		;
	ADD R4, R4, #1		;
	LDR R0, R4, #0		;
	ST R4, STACK_TOP	;
	BRnzp DONE_POP		;
UNDERFLOW
	ADD R5, R5, #1		;
DONE_POP
	LD R3, POP_SaveR3	;
	LD R4, POP_SaveR4	;
	RET


POP_SaveR3	.BLKW #1	;
POP_SaveR4	.BLKW #1	;
STACK_END	.FILL x3FF0	;
STACK_START	.FILL x4000	;
STACK_TOP	.FILL x4000	;
ERROR_EXP	.STRINGZ "Invalid Expression\n" ; STRING TO BE PRINTED IN CASE OF ERROR

ASC_AT 		.FILL x40	; ASCII VALUE OF '@'
ASC_ZERO 	.FILL x30 	; ASCII VALUE OF '0'
NEG_PLUS 	.FILL xFFD5	; NEG ASCII VALUE OF '+'
NEG_MINUS	.FILL xFFD3	; NEG ASCII VALUE OF '-'
NEG_MUL		.FILL xFFD6	; NEG ASCII VALUE OF '*'
NEG_DIV		.FILL xFFD1	; NEG ASCII VALUE OF '/'
NEG_EXP		.FILL xFFA2	; NEG ASCII VALUE OF '^'
NEG_SPACE	.FILL xFFE0	; NEG ASCII VALUE OF ' '
NEG_EQUAL	.FILL xFFC3	; NEG ASCII VALUE OF '='
NEG_ZERO	.FILL xFFD0	; NEG ASCII VALUE OF '0'

.END
